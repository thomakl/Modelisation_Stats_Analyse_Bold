setwd("H:/2A/Statistiques/Modelisation_Stats_Analyse_Bold")
signal <- readRDS(activation.Rdata)
signal <- readRDS("activation.Rdata")
signal <- readRDS("activation.Rdata")
signal
plot(signal)
signal("Sexe")
size(signal)
head(signal)
head(signal(1))
head(signal[1])
signal$Sexe
signal$Age
plot(signal$Age)
plot(Signal$Sujet,signal$Age)
plot(signal$Sujet,signal$Age)
plot(signal$Sujet,signal$Age)
plot(signal$Age)
plot(signal$PROD_G_Frontal_Inf_Tri_1_L)
summary(signal$PROD_G_Frontal_Inf_Tri_1_L)
boxplot(signal$PROD_G_Frontal_Inf_Tri_1_L)
boxplot(signal)
boxplot(signal[1:])
boxplot(signal$Volume_Cerebral)
boxplot(signal$Volume_Cerebral~signal$Index_Lateralisation_Hemispherique,data=signal, main="Car Milage Data",
xlab="région activée", ylab="Taux d'activation")
boxplot(signal$Volume_Cerebral~signal$Index_Lateralisation_Hemispherique,data=signal, main="Taux d'activation en fonction de la région cérébrale",
xlab="région activée", ylab="Taux d'activation")
boxplot(signal$Volume_Cerebral~signal$Index_Lateralisation_Hemispherique~signal$PROD_G_Frontal_Inf_Tri_1_L,data=signal, main="Taux d'activation en fonction de la région cérébrale",
xlab="région activée", ylab="Taux d'activation")
aire <- c(signal$Volume_Cerebral,signal$Index_Lateralisation_Hemispherique,signal$PROD_G_Frontal_Inf_Tri_1_L)
boxplot(aire, main="Taux d'activation en fonction de la région cérébrale",
xlab="région activée", ylab="Taux d'activation")
# ANOVA Ã  un Facteur
## Mise en oeuvre
donnees <- data.frame(engraisA=c(48,49,50,49), engraisB=c(47,49,48,48),engraisC=c(49,51,50,50))
donnees ## tips : donnÃ©es equilibrÃ©es permet de rÃ©duire le temps de calcul
stack(donnees)
rendement <- stack(donnees)$values
engrais <- stack(donnees)$ind
is.factor(engrais)
###
plot(rendement~engrais)
# Var Yi,k : rendement avec double indicage (i: type d'engrais ; k: parcel mesure du rendement)
# On veut explique Ã§a avec une moyenne de calage + alpha,i : effet diffÃ©rentiel du niveau i, du facteur engrais
# Rendement moyen du calage selon le type d'engrais
# + Terme d'erreur alÃ©atoire : epsilon i,k est normalement distribuÃ© : N(0,sigma^2) avec sigma^2 depÃ©ndante de i / (HomogÃ©initÃ© des varance) = mÃªme Variance dans ce cas
# HypothÃ¨se d'intÃ©ret : Ho: ÂµA=ÂµB=ÂµC  <=> alpahA = alphaB = alphaC=0  et H1: non Ho
#  ==> HomogeneitÃ© des variances raisonnable visuellement
#  et l'impact de l'engris sur le rendement : Raisonnable de rÃ©pondre par l'affirmative
###
# Stats descriptives par groupe
tapply(rendement,engrais,summary)
###
res.aov <- aov(rendement~engrais) # obtenir le tableau de l'analyse de la variance #  TEST de Fisher (tableau d'ANOVA) (après lm)
summary(res.aov)
# var expliqué / var non expliqué : Rejet H0 si stat Fisher élevé
# p-value inf 5 : Rejet H0 : "Engrais a un impact sur le rendement moyen"
###
# Estimation des paramètres du modèle
res <- lm(rendement~engrais)
anova(res) # tableau analyse des variances
summary(res)
#  Option callage :
# 1) Par defaut, calage sur le premier groupe (par ordre alpha-numérique) : µ=µA ; alpha,i=µi=µA ==> Structurellement alpha,A=0
# H0 : inutilité du modèle : µA=µB ; alpha,A=alpha,B=alpha,C
# inf 5% ==> Rejet H0
#  57,14% de la variablité du rendement est expliqué par l'engrais
#  estimation de l'ecart type d'erreur : Standart Residual Error : 0.8165
#  Intercept: estimation : moyenne du callage : 49 tonne en moyenne à l'hectare
# esttimation de l'effet differentiel
# engrais A au lieu de B, on perd une tonne à l'hectare
# Coefficient : tester individuellement les engrais / comparaison A contre B, A contre C != tester la globalité
# 3) Callage sur le 3ème groupe (par ordre alpha-numérique) : µ=µC ; alpha,i=µi=µC ==> Structurellement alpha,C=0
res <- lm(rendement~C(engrais,base=3))
summary(res)
# µ^A=µ^C+alpha,Â=50-1=49 / Estimate std_Intercept - Estimate_Std_groupe
# µ^A=µ^C+alpha,Â=50-2=48
# 4) Callage sur la moyenne : µ=µ0= Somme(µi)/I ; alpha,i=µi=µ0 ==> Structurellement Somme(alpha,i)=0 / données équilibrées
res <- lm(rendement~C(engrais,sum))
summary(res)
# µ^A=µ^0+alpha,Â=40+0=49 / Estimate std_Intercept - Estimate_Std_groupe
# µ^B=µ^0+alpha,B^=49-1=48
# µC = µ0+alphaC=µ0+(-alphaA-alphaB)=49-(0-(-1))=50
shapiro.test(res$residuals) # test normalité des residus : Rejet normalité
bartlett.test(rendement~engrais) # test d'homoscedasticité : Non rejet H0
plot(res$fitted, res$residuals) # Valeurs predites identiques : normal de voir des colonnes dans les residus
# Pas Structure particulière, donc leger rejet normalité non dramatique
# moyenne callage + residus ? + terme d'erreur'
# res$fitted = Yî,k=µî
# ==> Comparaison deux à deux de toutes les moyennes
pairwise.t.test(rendement,engrais,p.adjust="bonf")
# Test de H0: µA=µB* (Non rejet H0)
# H0 : µA=µC (Non rejet de H0)
# H0 : µB=µC (Non rejet de H0)
#=============================
# TP 3 : ANOVA
#--------------
# ENSC 2A
#==============================
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#####################################
# 1) ANOVA a un facteur
#####################################
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#--------------------------
# Jeu de donnees "engrais"
#--------------------------
# Saisie des donnees
#--------------------
donnees <- data.frame(engraisA=c(48,49,50,49),engraisB=c(47,49,48,48),engraisC=c(49,51,50,50))
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#--------------------------
# Jeu de donnees "lampes"
#--------------------------
# Saisie des donnees
#--------------------
duree<-c(1602,1615,1624,1631,1472,1477,1485,1493,1496,1504,1510,1548,1555,1559,1563,1575,
1435,1438,1448,1449,1454,1458,1467,1475,1493,1498,1509,1516,1521,1523,1585,1592,1598,1604,1609,1612)
procede<-c(rep("proc.1",4),rep("proc.2",7),rep("proc.3",5),rep("proc.4",8),rep("proc.5",6),rep("proc.6",6))
# Verifier que la classe de la variable qualitative "procede" est de type "factor"
procede <- as.factor(procede)
is.factor(procede)
# Visualisation des donnees
plot(duree~procede)
#  y (duree)(i=procede, k=duree) = µ (moyenne de calage) + alpha_i (effet differentiel) +E_i,k (tester N(0,sigma^2) (homogeneite des variances)
#  Ho : µ1 = ... = µ6 <---> alpha1=alpha2=...=alpha6=0
###
res.aov <- aov(duree~procede) # obtenir le tableau de l'analyse de la variance #  TEST de Fisher (tableau d'ANOVA) (après lm)
summary(res.aov)
# var expliqué / var non expliqué : Rejet H0 si stat Fisher élevé
# p-value inf 5 : Rejet H0 : "Engrais a un impact sur le rendement moyen"
###
# Estimation des paramètres du modèle
res <- lm(duree~procede)
anova(res) # tableau analyse des variances :décomposition de la variance de la duree en fct du procede (125000) (plus la partie non expliqué : 4616) : total = Variabilité de Y
#  Fort rejet car alpha inf 5%
#  Estimer les différents paramètres du modèle et la qualité du modèle :
summary(res)
# FStatistic inf à 5% : Fort rejet : modele utile : Impact du procédé sur la durée de vie moyenne des lampes
#  R2 Multiple : 96% de la duree de vie a été expliqué par le procédé
# Estimation de l'écart type du terme d'erreur : notre modele a un bruit de 12.4 H (qu'on suppose Gaussien : à tester)
# --> Moyenne de calage : fait par défaut sur le 1er groupe : Procédé 1 Donc intercept : µ1 = 1618 h
# ==> Effet diff avec le groupe 1 = 0 ; alpha_1 = 0 ; µ3 = µ1 + alpha_3 = 1618-58 = 1560 h
shapiro.test(res$residuals) # test normalité des residus : val sup à 5% : Non Rejet normalité : OK
bartlett.test(duree~procede) # test d'homoscedasticité : Non rejet H0 : OK ; var_1 = var_2 = ... = var_6 = var^2
plot(res$fitted, res$residuals) # Recherche d'une structure : Pas de forme = pas de structure visible
#  Il y a t'il des procede équivalents entres eux ?
# ==> Comparaison deux à deux de toutes les moyennes
res1 <- pairwise.t.test(duree,procede,p.adjust="bonf")
# Test de H0: µA=µB* (Non rejet H0)
# H0 : µA=µC (Non rejet de H0)
# H0 : µB=µC (Non rejet de H0)
res1
#  Pvalue sup à 5% : proc6~proc1 ; proc5~proc2
#  ==> Non rejet de Ho : µ1 = µ6 et µ2=µ5
#  Le reste : Rejet de Ho : µ_i = µ_y
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#####################################
# 2) ANOVA a deux facteurs
#####################################
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#----------------------------
# Jeu de donnees "rendement"
#----------------------------
# Saisie des donnees
#--------------------
rendement<-c(15,14,17,18,17,18,12,13,12,14,15,15,
16,19,18,23,24,25,15,14,14,12,11,10,
18,17,17,20,21,21,17,19,17,12,13,12)
plant<-as.factor(rep(rep(c("Plant I","Plant II","Plant III","Plant IV"),each=3),3))
engrais<-as.factor(rep(c("Engrais A","Engrais B","Engrais C"),each=12))
donnees<-data.frame(rendement,plant,engrais)
#  Visualisation des données
plot(donnees)
plot(rendement~plant)
#  y (duree)(i=engrais, j=plant, k=parcelle) = µ (moyenne de calage) + alpha_i (effet differentiel engris) + alpha_i (effet differentiel plant) +B_i,j(interaction (d'ordre 1) engrais x plant) E_i,k (terme de variabilité)(tester N(0,sigma^2) (homogeneite des variances)
#  Pourquoi expliquer ce rendement avec un engrais et un plant : quel est le facteur en charge du rendement ?
#  Ho : µ1 = ... = µ6 <---> V(i,j) alpha_i_engrais=alpha_j_plan=+B_i,j(engrais x plant)=0
# Si rejet de Ho ,
# Ho :V(i,j),B_ij(engrais x plant)=0
# Si Ho précédent NON rejetée
# Si pas d'effet d'interaction
# Ho : Vi, alpha_i(engrais)=0
# Ho : Vj, alpha_j(plant)=0
# Si interaction dans mon modele : NOK : l'engrais ou le plant interagit entre eux
res.aov <- aov(rendement~procede) # obtenir le tableau de l'analyse de la variance #  TEST de Fisher (tableau d'ANOVA) (après lm)
summary(res.aov)
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#----------------------------
# Jeu de donnees "lait"
#----------------------------
# Saisie des donnees
#--------------------
rdt.laitier<-c( 8 ,11, 11, 10, 7, 12, 13, 14, 11, 10, 10, 12, 12, 13, 14, 17, 13, 17, 14, 13,
8, 9, 8, 10, 9, 10, 7, 10, 12, 11, 11, 9, 11, 11, 12, 17, 19, 17, 16, 21)
aliment<-as.factor(rep(rep(c("paille","foin","herbe","alim.ens."),each=5),2))
dose<-as.factor(rep(c("faible","forte"),each=20))
donnees<-data.frame(rdt.laitier,aliment,dose)
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#####################################
# 3) ANOVA a trois facteurs
#####################################
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
#----------------------------
# Jeu de donnees "lecture"
#----------------------------
temps<-c(1450 ,1495, 1668, 1445, 1433, 1702,
966, 1168, 590, 1104, 1027, 788,
1224, 1286, 1098, 1344, 1182, 1524,
765, 840, 1183, 1092, 893, 1150)
sexe<-as.factor(rep(c("G","F"),each=12))
age<-as.factor(rep(rep(c("petit","grand"),each=6),2))
mot<-as.factor(rep(rep(c("concret","abstrait"),each=3),4))
donnees<-data.frame(temps,sexe,age,mot)
donnees
signal <- readRDS("activation.Rdata")
aire <- c(signal$Volume_Cerebral,signal$Index_Lateralisation_Hemispherique,signal$PROD_G_Frontal_Inf_Tri_1_L)
plot(aire)
# Yi = beta0 + Sp(BiÂµXi+e) avec e suit N(0,sigma^2)
# Mise en oeuvre sur un jeu de donnÃ©es simulÃ©s
n <- 100
x1 <- runif(n,min=-5,max=5)
x2 <- runif(n,min=-5,max=5)
x3 <- runif(n,min=-5,max=5)
x4 <- runif(n,min=-5,max=5)
x5 <- runif(n,min=-5,max=5)
sigma <- 2
e <- rnorm(n,mean=0, sd=sigma)
y <- 4 - 2*x1 - 5*x3 + 1.4*x5 + 3*x2 + 0.8*x4+e
matYX <- data.frame(y,x1,x2,x3,x4,x5)
head(matYX)
summary(mtYX)
plot(matYX)
if (!require(PCAmixdata))
{
install.packages("PCAmixdata")
library(PCAmixdata)
}
res_acp <- PCAmix(matYX,ndim = 2, graph=FALSE)
# Contribution des variables aux axes principaux
res_acp$sqload # carrÃ© du coefficient de corrÃ©lation entre les axes principaux et les variables
plot(res_acp,choice = "sqload")
# On explique au total % dim1 + %dim2 = 53% de l'inertie total au nuage de points
# (inertie = nb de variable * somme des variances)
# SI orthogonal => pas de sens de le garder car porte peu d'informations'
plot(matYX)
res <- lm(y~ x1  + x2 + x3 + x4 + x5, data = matYX)
summary(res)
# Fstatistic <- test F
# Ho = Beta1 = Beta2 = Beta3 = 0
# H1 =
# R^2 (variances Y expliquÃ© par modele) 99%
#  1 - SSE (somme carre des residus) /SST (somme des carres totale) = 1 - S(y-ychap)^2
# Adjujsted R^2 : utiliser pour selectionner parmi les 5 var celui qui est utile
#  1 - (1-R^2)(n-1)/(n-k-1) avec n = nb evaluation, k = nb de variable explicative = 1 - (SSE/n-p-1)/(SST/n-1)
# diff R/ R^2 : R2 selectionne le nb de variable utile au modele
# Nb de variable adequate : optimum entre nb variable R2 et variances explique R
# Pvalue superieur et estimateur n'arrive pas estimer la variable '
#  donc relancer le modele de regression en enlevant la variable inutile (ici x4)
par(mfrow=c(1,2))
plot(res$fitted,res$residuals)
abline(h=0,col=2)
plot(res$fitted)
abline(0,1,col=2)
par(mfrow=c(1,1))
# dans les deux graphiques, tout est OK
shapiro.test(res$residuals)
head(signal)
